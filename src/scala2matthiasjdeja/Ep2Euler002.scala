package scala2matthiasjdeja

/**
  * Created by admin on 2016-06-04.
  *
  *
  *
  * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
  *
  * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
  *
  * By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
  *
  */
object Ep2Euler002 {

  def main(args: Array[String]) {
    val sum = functionalVersion()
    println(sum)
  }

  // procedural, imperative, verbose
  private def mostJavaesqueVersion(): Int = {
    var xnm1 = 1
    var xn = 2
    var sum = 0
    while (xn < 4e6) {
      if (xn % 2 == 0) sum += xn
      val temp = xn
      xn += xnm1
      xnm1 = temp
    }
    sum
  }

  private def stillImperativeVersion(): Int = {
    var (sum, xnm1, xn) = (0, 1, 2) // combined assignment (c.f. Python tuple unpacking)
    while (xn < 4e6) {
      if (xn % 2 == 0) sum += xn
      val temp = xn
      xn += xnm1
      xnm1 = temp
    }
    sum
  }

  private def functionalVersion(): Int = {
    def fib: Stream[Int] = {

      // how do we iterate through the sequence? (recursively!)
      def recurse(xmn1: Int, xn: Int): Stream[Int] =
        Stream.cons(xmn1, recurse(xn, xmn1 + xn)) // concatenating an object with a Stream (a lazy parameter, infinite recursion is avoided)

      // return the initialized recursive sequence
      recurse(1, 2)
    }

    fib.filter({ x => x % 2 == 0 }).takeWhile({ x => x < 4e6 }).sum
  }

  private def shorthandFunctionalVersion(): Int = {
    /**
      * Since `fib` is nothing more than `recurse` with some initial parameters (the first and second members of the Fibonacci sequence)
      * we can do without `recurse` if we define default parameters
      */
    def fib(xmn1: Int = 1, xn: Int = 2): Stream[Int] = Stream.cons(xmn1, fib(xn, xmn1 + xn))
    (fib() filter (_ % 2 == 0) takeWhile (_ < 4e6)).sum
  }

}
